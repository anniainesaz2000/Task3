package bgu.spl.net.impl.tftp;

import bgu.spl.net.api.BidiMessagingProtocol;
import bgu.spl.net.srv.BlockingConnectionHandler;
import bgu.spl.net.srv.ConnectionHandler;
import bgu.spl.net.srv.Connections;

import java.nio.charset.StandardCharsets;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Arrays;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;


class holder{
    static ConcurrentHashMap<Integer,Boolean> ids_login = new ConcurrentHashMap<>();
    static ConcurrentHashMap<Integer,String> idsToUsermames = new ConcurrentHashMap<>();

}

class HashMapErrors{
    public static ConcurrentHashMap<Integer,TFTPErrorPacket> errors = new ConcurrentHashMap<>();
    public void HashMapErrors(){
        TFTPErrorPacket errorPacket0 = new TFTPErrorPacket((short) 0, "Not defined, see error message (if any)");
        errors.putIfAbsent(0, errorPacket0);

        TFTPErrorPacket errorPacket1 = new TFTPErrorPacket((short) 1, "File not found – RRQ DELRQ of non-existing file");
        errors.putIfAbsent(1, errorPacket1);

        TFTPErrorPacket errorPacket2 = new TFTPErrorPacket((short) 2, "Access violation – File cannot be written, read or deleted");
        errors.putIfAbsent(2, errorPacket2);

        TFTPErrorPacket errorPacket3 = new TFTPErrorPacket((short) 3, "Disk full or allocation exceeded – No room in disk");
        errors.putIfAbsent(3, errorPacket3);

        TFTPErrorPacket errorPacket4 = new TFTPErrorPacket((short) 4, "Illegal TFTP operation – Unknown Opcode");
        errors.putIfAbsent(4, errorPacket4);

        TFTPErrorPacket errorPacket5 = new TFTPErrorPacket((short) 5, "File already exists – File name exists on WRQ");
        errors.putIfAbsent(5, errorPacket5);

        TFTPErrorPacket errorPacket6 = new TFTPErrorPacket((short) 6, "User not logged in – Any opcode received before Login completes");
        errors.putIfAbsent(6, errorPacket6);

        TFTPErrorPacket errorPacket7 = new TFTPErrorPacket((short) 7, " User already logged in – Login username already connected");
        errors.putIfAbsent(7, errorPacket7);


    }

}
public class TftpProtocol implements BidiMessagingProtocol<byte[]>  {
    private boolean shouldTerminate = false;
    private int connectionId;
    private Connections<byte[]> connections; //should be String?
    private String userName;
    private HashMapErrors hashMapError = new HashMapErrors();
    private Objects ACKLock;



    @Override
    public void start(int connectionId, Connections<byte[]> connections) {
        // TODO implement this
        this.shouldTerminate = false;
        this.connectionId = connectionId;
        this.connections = connections;
        holder.ids_login.put(connectionId, true);
        //throw new UnsupportedOperationException("Unimplemented method 'start'");
    }

    @Override
    public void process(byte[] message) {//cope with different kinds of opcodes (client requests)
        // TODO implement this
        //loop with condition that a client added or deleted a file (announce everyone)
        TftpEncoderDecoder.Opcode opcode = peekOpcode(message);
        switch (opcode) {
            case None:
                break;
            case LOGRQ:
                if(holder.ids_login.get(this.connectionId)){
                    byte[] errorAlreadyLoggedIn = makeError(7);
                    this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                }

                else{
                    //byte[] userNameBytes = Arrays.copyOfRange(message,2, message.length -2);
                    this.userName = new String(message,2,message.length -2, StandardCharsets.UTF_8);
                    if(holder.idsToUsermames.containsValue(this.userName)){
                        byte[] errorUserNameExists = makeError(0);//value 7?
                        this.connections.send(this.connectionId, errorUserNameExists);
                    }

                    else{
                        holder.ids_login.put(this.connectionId,true);
                        holder.idsToUsermames.put(this.connectionId, this.userName);
                        byte[] ack ={0,4,0,0};
                        this.connections.send(this.connectionId, ack);
                    }
                }
                break;
            case RRQ:
                if(!holder.ids_login.get(this.connectionId)){
                    byte[] errorAlreadyLoggedIn = makeError(6);
                    this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                }
                else{
                    String fileName = new String(message,2,message.length -2, StandardCharsets.UTF_8);
                    readFile(fileName);
                }

                break;

            case WRQ:
                if(!holder.ids_login.get(this.connectionId)){
                    byte[] errorAlreadyLoggedIn = makeError(6);
                    this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                }
                else{
                    String fileName = new String(message,2,message.length -2, StandardCharsets.UTF_8);
                    String filePath = "server/Flies/";
                    String fullPath = filePath + fileName;
                    try (FileInputStream fis = new FileInputStream(fullPath)) {
                        byte[] errorAlreadyLoggedIn = makeError(5);
                        this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                    }catch (IOException e){
                        try (FileOutputStream fos = new FileOutputStream(fullPath)) {
                            //check
                            //create a list that contains all the filenames exist in files folder and done written - field + change evey place that we check if exists in the folder to check from the list
//                            String dataToWrite = "Hello, this is a sample text.";
//                            fos.write(dataToWrite.getBytes());
//                            System.out.println("Data has been written to the file.");
                        } catch (IOException er) {
                            byte[] errorAlreadyLoggedIn = makeError(2);
                            this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                        }
                    }

                }


                break;
            case ACK:
                if(!holder.ids_login.get(this.connectionId)){
                    byte[] errorAlreadyLoggedIn = makeError(6);
                    this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                }
                else{

                }
                //ACKLock.notifyAll();
                break;
            //case ERROR:

                //break;
            case DATA:
                if(!holder.ids_login.get(this.connectionId)){
                    byte[] errorAlreadyLoggedIn = makeError(6);
                    this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                }
                else{

                }

                break;

            case DIRQ:
                if(!holder.ids_login.get(this.connectionId)){
                    byte[] errorAlreadyLoggedIn = makeError(6);
                    this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                }
                else{

                }

                break;

            case DELRQ:
                if(!holder.ids_login.get(this.connectionId)){
                    byte[] errorAlreadyLoggedIn = makeError(6);
                    this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                }
                else{

                }

                break;

            case BCAST:
                if(!holder.ids_login.get(this.connectionId)){
                    byte[] errorAlreadyLoggedIn = makeError(6);
                    this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                }
                else{

                }

                break;

            case DISC:
                if(!holder.ids_login.get(this.connectionId)){
                    byte[] errorAlreadyLoggedIn = makeError(6);
                    this.connections.send(this.connectionId, errorAlreadyLoggedIn);
                }
                else{

                }

                break;
        }

        throw new UnsupportedOperationException("Unimplemented method 'process'");
    }

    private byte[] makeError(int errorCode){

        switch(errorCode){
            case 0:
                return this.hashMapError.errors.get(0).toByteArray();
            case 1:
                return this.hashMapError.errors.get(1).toByteArray();
            case 2:
                return this.hashMapError.errors.get(2).toByteArray();
            case 3:
                return this.hashMapError.errors.get(3).toByteArray();
            case 4:
                return this.hashMapError.errors.get(4).toByteArray();
            case 5:
                return this.hashMapError.errors.get(5).toByteArray();
            case 6:
                return this.hashMapError.errors.get(6).toByteArray();
            case 7:
                return this.hashMapError.errors.get(7).toByteArray();
            default:
                return null;
        }
    }

    private void readFile(String fileName) {
        String filePath = "server/Flies/";
        String fullPath = filePath + fileName;
        List<Byte> data = new ArrayList<>();

        short size = 0;
        short blockNumber = 1;
        try (FileInputStream fis = new FileInputStream(fullPath)) {
            int byteValue;
            while ((byteValue = fis.read()) != -1) {
                data.add((byte)byteValue);
                size++;
                if(size==511){
                    handleDataPacket(size, blockNumber, data);
                    size=0;
                    blockNumber++;
                    data.clear();
                    //ACKLock.wait(); wait for ack packet
                }
            }
            handleDataPacket(size, blockNumber, data);
            //ACKLock.wait(); wait for ack packet
        } catch (IOException e) {
            byte[] errorFileDoesntExists = makeError(1);
            this.connections.send(this.connectionId, errorFileDoesntExists);
        }
    }

    public void handleDataPacket(short size, short blockNumber,  List<Byte> data){
        byte[] packetSize = new byte[]{(byte) (size >> 8), (byte) (size & 0xff)};

        byte[] dataPacket = new byte[size + 7];
        dataPacket[0] = (byte)0;
        dataPacket[1] = (byte)3;
        dataPacket[2] = packetSize[0];
        dataPacket[3] = packetSize[1];

        byte[] blockNumberByte = new byte[]{(byte) (blockNumber >> 8), (byte) (blockNumber & 0xff)};
        dataPacket[4] = blockNumberByte[0];
        dataPacket[5] = blockNumberByte[1];

        int j = 6;
        for (int i = 0; i < data.size(); i++) {
            dataPacket[j] = data.get(i);
            j++;
        }

        dataPacket[dataPacket.length-1] = (byte) 0;
        this.connections.send(this.connectionId, dataPacket);
    }


    private TftpEncoderDecoder.Opcode peekOpcode(byte[] message) {//Anni
        assert message.length >= 2;
        int u16Opcode = (message[1] & 0xFF) << 8 | (message[0] & 0xFF);
        return TftpEncoderDecoder.Opcode.fromU16(u16Opcode);
    }

    @Override
    public boolean shouldTerminate() {
        // TODO implement this
        if(this.shouldTerminate){
            this.connections.disconnect(this.connectionId);
            holder.ids_login.remove(this.connectionId);
        }
        return this.shouldTerminate;

        //throw new UnsupportedOperationException("Unimplemented method 'shouldTerminate'");
    } 


    
}
